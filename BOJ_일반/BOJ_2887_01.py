# 1. 관찰

# 크루스칼 알고리즘은 가장 적은 비용으로 모든 노드를 연결하기 위해 사용하는 알고리즘입니다
# 여기서 관찰은 각 두행성의 x,y,z를 계산해서 최소를 계산해서 모든 노드의 최소비용을 계산하는것보다
# 각각의 x,y,z별로 행성들을 정렬해서 인접한 행성의 거리가 최소가 된다라는 것을 이용하는 것이 좋다 ( 그리디 ) => 어떻게 최소가 되게 하는 아이디어가 필요할까?
# 또 최소비용으로 모든 간선들을 연결하게 하는것도 크루스칼 알고리즘이라는 것을 알면된다

# 그래프 + 그리디(정렬) + 크루스칼(최소비용의 간선)  + 유니온 파인드 ( 부모노드 찾기 )
# 우선 가장 짧은 거리의 간선을 가지고 오기 위해 모든 정점들을 각 X,Y,Z 좌표별로 정렬한다
# X좌표별로 정렬후 절댓값 계산 즉 비용을 계산해서 결과값에 담아준다
# Y좌표별로 정렬후 절댓값 계산 즉 비용을 계산해서 결과값에 담아준다
# Z좌표별로 정렬후 절댓값 계산 즉 비용을 계산해서 결과값에 담아줁다
# 이 모든 간선들을 전부 정렬하게 되면 최소비용의 간선부터 앞에 오게 된다 ( 두행성사이의 거리에서 X,Y,Z중 최이므로 1번행성과 2번행성사이의 X좌표 차 절댓값이
# 어떤 1번과 다른 번호의 행성의 X좌표값보다 최소가된다 즉 가장 가까운 양옆의 최소비용의 간성을 구할 수 잇따는 것이 핵심이다
# 1번부터 5번 해성에서 X값을 기준으로 정렬해서 -1(3번) 10(4번) 11(1번) 14(2번) 19(5번)가 됫다 => 1번행성은 가장 가까운 4번과 2번중 4번과의 간선이 최소비용이 된다는 것을 알 수 잇고
# 후에 Y값을 기준으로 정렬했을 경우도 양옆의 행성과의 거리가 최소가 되므로 최종적으로 마지막에 X,Y,Z 차이 절댓값중 최소가 앞에 오게 된다

# 각 행성의 기준이 아닌 X,Y,Z좌표를 기준으로 정렬해야 된다 역으로 생각
# 정렬하면 사이 사이의 값 즉 터널의 최소비용을 효과적으로 얻을 수 있다
# 이제 이 모든 간선들을 정렬하면 최소비용의 간선부터 앞에서 오게되고 정렬된다 => 최소스패닝트리 ( 최소비용의간선을 찾기 )
# 이제 부모를 찾기 위해 유니온 파인드를 사용한다

# 결국 모든 정점들은 한 정점 0번을 부모로 하게 끝한다
# union_find를 통해서 부모를 같계 맞춰준다
# 그리고 크루스칼을 통해서 간선을 연결하면 최소비용의 합을 더해준다
# 부모가 이미 같은 후순위 즉 최소비용의 간선들이 아닌경우에는 이미 부모가 같은 최소비용계산에서 union_find를 해주었기때문에 넘긴다


# 유니온 파인드 알고리즘이란?
# 그래프 알고리즘의 일종으로서 상호 배타적 집합, Disjoint-set 이라고도 합니다.
# 여러 노드가 존재할 때 어떤 두 개의 노드를 같은 집합으로 묶어주고,
# 다시 어떤 두 노드가 같은 집합에 있는지 확인하는 알고리즘입니다.
# 그러기 위해 두 가지 연산이 존재합니다.
#
# Find
#
# 노드 x 가 어느 집합에 포함되어 있는지 찾는 연산
#
# Union
#
# 노드 x가 포함된 집합과 노드 y가 포함된 집합을 합치는 연산
import sys

si = sys.stdin.readline

N = int(si())
planet = []
for i in range(N):
    x,y,z = map(int, si().split())
    planet.append((x,y,z,i)) # 인덱스는 zero based
# x,y,z 각각 기준으로 정렬해서 양옆의 사이의 거리와 간선의 정보를 담는다
edges = []
for i in range(3):
    planet.sort(key=lambda x : x[i]) # x,y,z 기준으로 정렬하기
    for j in range(N):
        edges.append((abs(planet[j-1][i]-planet[j][i]), planet[j-1][3],planet[j][3]))
edges.sort() # 이제 최소스패닝트리를 시작할 준비가 완료되엇다
# 최소비용의 간선들이 차례로 줄을 서있고 첫번째 간선부터 연결할 것이다

# 두 행성 사이의 연결 여부는 부모가 같냐로 판단하기 위해 체크하기 위해서 parent 리스트를 만들고 체크한다 => 배열로서 자료구조 (백업)

def find_parent(x, parent):
    if x != parent[x]:
        parent[x] = find_parent(parent[x] , parent) # x의 부모 즉 연결되어 있는 노드를 찾기 위해서 재귀적으로 탐색한다
    return parent[x] # x의 부모와 자기자신이 같다면 연결되어 있다는 의미
def union_find(a,b,parent):
    a = find_parent(a,parent)
    b = find_parent(b,parent)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b
parent = [i for i in range(N)]
total =  0
for i in range(len(edges)): # 각 간선들을 돌면서 부모노드를 찾는다
    # 같은 부모 노드가 아니라면 최소비용에 더하고 같은 부모라면 패스한다
    if find_parent(edges[i][1],parent) != find_parent(edges[i][2],parent): # 부모가 다르다면 부모를 같게 해주면서 간선을 연결해준다
        union_find(edges[i][1],edges[i][2],parent) # 유니온 파인드가 부모를 같게 해주는 연결을 담당한다
        total += edges[i][0]

print(total)


