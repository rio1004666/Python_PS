# 현대모비스 문제와 비슷
# 1번을 선택 2번 3번 4번 5번과의 거리를 생각해봄
# 2번이 왼쪽인지 오른쪽인지 모르고 3번도 모르고 4번도 모름
# 1번 고정하고 다른위치를 찾으려면 규칙이 힘듬
# 관찰을 해야만함
# 2번에서 거리를 확인해보면 5, 3 9, 6이 나옴
# 4번에서 거리를 확인해보면....쭉쭉....나올것임
# 사이의 거리가 다양하게 등장하면
# 가장 좋은 힌트는 어떤 관계인가 => 가장 멀리있는 두 정점이다
# 2번과 4번이 9이고 숫자들 사이의 대소관계로 분명하다
# 즉 가장 멀리있는 두 숫자사이라고 볼수있고
# 가장멀리있다는건 둘 중에 (2번과 4번중에)
# 맨처음과 끝에는 2번과 4번이 무조건 고정이다
# 또 4번과 2번사이도 9가될수밖에 없다
# 1번 관찰 => 가장 멀리 있는 두 정점을 잡고 시작한다
# 즉 처음에 어떤 정점이 올수잇는지 알수잇고 2번이라고 가정하자
# 두번째부터 n번째까지의 거리를 어떻게 알수잇냐
# 2번에서 두번째 세번째 4번째 위치는 가장 가까운위치
# 즉 2번에서 가장 가까운 위치에 있는 정점부터 배치하면된다
# 2번에서 가장 가까운건 3번 그다음 5번 그다음 1번 마지막 4번 정점이 된다!!!
# 즉 정리하면 확정적으로 2번노드는 가장 처음으로 고정이고
# 왼쪽에 있을 경우가 없고 오른쪽부터 배치가 차례로 된다!!!!!
# 이 관찰만 하면 그대로 구현만하면 된다!!!
# ad-hoc이라고 불림( 특별한 목적을 위해서라는 의미....)( 그리디는 부분의 최적이 전체의 최적이라고 불림 )


import sys
si = sys.stdin.readline
N = int(si())
a = [list(map(int, si().split())) for _ in range(N)]
# 가장 먼 두 고릴라 찾기
v, I, J = 0, 0, 0
for i in range(N):
    for j in range(N):
        if a[i][j] > v:
            v = a[i][j]
            I, J = i, j
def solve(first):
    # 제일 앞에 first가 올 때의 순서 출력
    ord = [(a[first][i], i) for i in range(N)]  # (거리, 번호)
    ord.sort()
    for dist, idx in ord:
        print(idx + 1, end=' ')
    print()
solve(I)
solve(J)










