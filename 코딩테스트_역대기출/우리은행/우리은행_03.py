# 언제 어떻게 부스트를 먹어야할지 모르니까
# 누가봐도 불규칙한 상황을 어떻게 알겠습니까...?
# 그래서 모든 경우의 수를 다 확인하는데 경우의 수가 많으니 DP로 접근하자
# 모든 경우의수를 다해봄으로써 dp를 사용한다
# 또 k값과 테이블 값이 10억이므로 거의 더하기 빼기 형태의 수학적계산일 것이다
# dp[i] = 1번~i번 일정소화 최소시간
# dp[N]구하기
# dp[0] = 0
# dp[i] = dp[i-1] + b 부스터 없이 사용하기
# dp[i] = dp[k-1] + a * (i-k+1)
# i번 업무를 처리할 때 부스터 상태로 처리함 => 부스터 사용하기
# 이 부스터 사용한 곳을 찾기위해 이분탐색 사용
# k 부스터 효력일전에서 가장 왼쪽원소를 찾는다 => 최대한 많은 원소들이 효력을 보아야 한다
# 100일째에 유효기간 k = 10일이면
# 적어도 91일부터 부스터를 먹을 수 있다
# 이 91일보다 크거나 같은 날짜부터 가장 작은 값에서 부스터를 먹는다
# 이 91일에서 가장 가까우면서 91일 이상인 수 중 가장 작은 것을 찾기 위해 이분탐색을 사용한다
# 또 정렬이 되어 있기때문에 이분탐색을 사용하는 근거를 찾아볼 수 있다
# lower_bound사용 (c++)
# 혹은 투포인터를 사용할 수 있다 => 연속된 구간이고 이전의 값을 이용해 다음값을 구할 수 있다
# i값을 증가해오면서 이전일정의 각 i마다 k도 같이 기억
# 이전의 k값을 가져와서 사용함
import sys

si = sys.stdin.readline
n, m, a, b, d = map(int, si().split())
schedule = [0] + list(map(int, si().split()))
dp = [0 for _ in range(n + 1)]
k = 1
for i in range(1, n + 1):
    # 부스터 없이 i 번 일을 처리하는 경우
    dp[i] = dp[i - 1] + b
    # 부스터를 써서 i 번 일을 처리하고 싶은 경우
    # 투포인터를 사용하는 경우
    # 이 while문도 n-1번 반복이므로 O(N)이다
    # K값은 계속 증가시키면서 K = I일때 멈춘다 자기자신한테 올때까지
    # 자기자신이 5고 효력은 4라면 2 3 4 5일이 효력이 될 수 있고
    # 1이라면 K값을 증가시켜서 땡겨와서 효력이 발생하는 일을 한번더 찾을것이고
    #  2가되면 효력 범위 안에 들어오므로 멈춘다 여기서부터 효력을 발생하는 걸로 생각한다
    while schedule[i] - schedule[k] >= d:  # k = n 이면 무조건 종료
        k += 1

    dp[i] = min(dp[i], dp[k - 1] + a * (i - k + 1) + m)
print(dp[n])
