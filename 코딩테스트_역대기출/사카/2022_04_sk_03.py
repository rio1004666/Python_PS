# 2n개의 숫자를 쓸수있는 원판
# 위치번호가 0번부터 2n-1이 써져잇고
# 각 위치마다 토핑번호가 써져있다 별도로
# 0번위치에 서있다 => 모든 토핑을 먹은후에 최소거리
# 1번토핑부터 먹고 2번토핑을 먹고 3번토핑을 먹고 순차적으로...
# 매번 두개의 선택지가 있다 1번토핑중 무엇을 먹어야할지 고민해야함
# 토핑은 같은 그룹임
# 향기를 맡고싶은 토핑번호가 순서대로 들어옴
# 입력은 3, 2, 3, 1, 5, 3이면
# 3번토핑중 하나 먹고 2번토핑중 하나먹고 3번토핑중 하나먹고....
# 이렇게 먹으면서 이동하는 최소거리를 구하라
# 내생각으론 상태를 생각하고 dfs탐색하면 되지않을까? (완탐)
# 그런데 ...
# n은 150 전체 조각은 300개
# 향기배열은 150개
# 향기 배열이 주어지면 [1,2,3,4]
# 문제를 어렵게 만든 요소는 같은 향기라도 두개 존재가능
# 선택지가 여러가지 존재하므로 무조건 가까운쪽으로 가는것이 좋은가? 그리디하게? 놉
# 좀 먼곳으로 이동해도 그다음이 더짧아질수도 있따!
# 그리디가 아니라는 것은 모든 경우를 확인해야한다
# 즉 여러가지 선택확인
# 다행인건 즉 일일이 모든 경우의수를 확인하지않아도 되는건
# i번째까지 향기를 잘 맡아왓다면
# 그 다음 향기를 맡을 때 그 직전 향기만 체크하면디
# 이러한 상황에서 다이나믹프로그래밍으로 한다 => 완전탐색 시도 실패 (너무 많음)+ 그리디 안됨
# 2차원 배열 dy[i][0] = 1부터 i번째향을 최단거리로 맡고 i번째 향의 A위치에 도착
# 2차원 배열 dy[i][1] = 1부터 i번째향을 최단거리로 맡고 i번째 향의 B위치에 도착
# 방향은 왼쪽으로 도냐 오른쪽으로 도냐 두가지인경우이므로 !!!
# min(dy[s][0],dy[s][1]) 최종적으로 왼쪽 or 오른쪽 둘중 최솟값 고름
# 이 문제에서 향기배열이 있을 경우 각 향기마다 선택지가 a로가냐 b로 가냐 두가지 임
# 완전탐색한다고 치면 2^s경우가 존재 s는 150임....
# 시작점은 0번인덱스
# 첫 a위치에 도달하는 경우 한가지뿐임
# dy[1][0]과 dy[1][1]은 바로 구해짐
# 점화식을 세우면된다
# 4 4
# 2 1 2 1 3 4 4 3
# 1 2 3 4
# => 4
import sys

INF = 1000000009
si = sys.stdin.readline
n, m = map(int, si().split())
a = list(map(int, si().split()))
smells = list(map(int, si().split()))
# 각 향기마다 A랑 B위치 기억해두기
place = [[-1, -1] for _ in range(n + 1)]
for i in range(n * 2):
    smell = a[i]
    if place[smell][0] == -1:
        place[smell][0] = i
    else:
        place[smell][1] = i


def get_dist(x, y):
    # x번 위치에서 y번 위치로 가는 최단거리 계산
    if x > y:
        x, y = y, x
    return min(y - x, n * 2 - (y - x))


# 배열 정의
dy = [[INF, INF] for _ in range(m + 1)]
dy[0][0], dy[0][1] = get_dist(0, place[smells[0]][0]), get_dist(0, place[smells[0]][1])
for i in range(1, m):
    prev = smells[i - 1]  # 직전에 맡은 향 번호
    cur = smells[i]  # 이번에 맡은 향 번호
    for cur_k in range(2):
        # dy[i][cur_k] 을 계산해줄 차례
        curPosition = place[cur][cur_k]
        prevA, prevB = place[prev][0], place[prev][1]
        dy[i][cur_k] = min(dy[i - 1][0] + get_dist(prevA, curPosition),  # 직전에 A번 위치 선택
                           dy[i - 1][1] + get_dist(prevB, curPosition))  # 직전에 B번 위치 선택
print(min(dy[m - 1]))
