# 2차원 격자 N행 M열 => BFS DFS 그래프 문제는 단순히 물리적인 노드 칸 집 뿐만 아니라 상태 변화도 적용된다
# 자동차가 1행 1열 위치에 있따
# 가고 싶은 곳은 N행 M열에 도착하고 싶다
# 2차원 격자에는 총 3가지 타일이 존재한다
# 1번째 타일은 평범한 도로
# 2번째 타일은 주유소
# 3번째 타일은 산 (이동불가)
# 첫번째 조건 : 산은 이동불가
# 두번째 조건 : 상하좌우로 인접한 곳만 이동가능
# 세번째 조건 : 한칸이동마다 연료가 1씩 줄어듬
# 네번째 조건 : 연료통은 최대 K만큼의 연료를 들고 있을 수 있다
# 다섯번째 조건 : 주유소에서만 주유 가능
# 이동하다가 기름 떨어지면 이동 할 수 없음
# 가다가 주유소에서 1번 주유하면 도착할 수 있음
# 지도의 정보와 K값이 주어졌을 경우에 도착지에 가기 위해
# 주유의 최소 횟수를 구하는 문제
# N과 M은 50 K=50 도착할 수 있는 방법도 존재
# 벽부수고 이동하기2  문제와 비슷
# BFS 그래프 정점 간선
# 정점은 (i,j,oil)로 정의할것이고 i행j열,남아있는 연료상태를 정점으로 표현
# 이 문제가 원하는 정답 풀이는 (0,0,k) 로 시작
# (n-1,m-1,*)  아 도착지점의 상태일것이고
# 시작점부터 도착지점까지 가는 거리중 가장 짧은 거리를 구함
# 최단거리 키워드 그런데 기름을 채우는 행위만 말했는데
# 거리랑 어떻게 매칭이되나?
# 간선을 어떻게 설정하느냐....
# 간선 두개의 정점을 잇는 행위이고
# 인접한 상하좌우 이동할때 다음상태에서는 oil-1값이 남을것이고
# 대신 기름을 넣지 않고 이동하는경우 가중치를 0으로 한다
# 즉 기름을 안넣으면 0으로 써주면 짧은 거리가 되는것과 같게된다!!!!
# 또 기름을 넣는 행위는 1로 써주면 거리가 증가되는것과 같게된다
# 우리가 알고 있는 간선의 가중치는 1로 가정하지만
# 여기서는 가중치가 0이다.... 일반적인 bfs로는 생각하기 힘들다
# deque(더블엔디드큐)를 사용해서 0인간선의 정점을 큐앞에 넣고
# 1인간선의 정점을 큐뒤에 넣는다
# 참고 : 다익스트라로 풀어도 됨  => 간선의 가중치가 다를경우 최소경로
import sys
from collections import deque

si = sys.stdin.readline
n, m, K = map(int, si().split())
grid = [si().strip() for _ in range(n)]


def in_range(x, y):
    return 0 <= x < n and 0 <= y < m


dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]
que = deque()
que.append((0, 0, K))
# 거리배열을 만들어준다 격자 칸의 기름상태를 저장할 격자배열
dist = [[[100000 for _ in range(K + 1)] for __ in range(m)] for ___ in range(n)]
dist[0][0][K] = 0
while que:
    x, y, oil = que.popleft()
    # 크게 두가지의 상태로 간선을 잇는 설계를 하게 됨

    # 인접한 칸들로 이동 (가중치 0인 간선)
    for dx, dy in dirs:
        nx, ny, n_oil = x + dx, y + dy, oil - 1
        if not in_range(nx, ny): continue
        if oil == 0: continue # 남아있는 연료가 없으면 이동 불가
        if dist[nx][ny][n_oil] <= dist[x][y][oil]: continue # 이동할 위치를 간적이 있다면 안간다 ( 최소가 찍히기때문에 )
        if grid[nx][ny] == 'M': continue
        que.appendleft((nx, ny, n_oil)) # 왼쪽에 넣어준다 ( 더 작은 간선은 왼쪽에 넣어야 먼저 빠진다 )
        dist[nx][ny][n_oil] = dist[x][y][oil] # 그리고 최솟값을 갱신해준다

    # 기름 채우는 이동 (가중치 1인 간선)
    # 현재 칸에서 기름이 가득차있는 곳의 거리보다 작아야지만 간선의 이동을 한다 즉 거리의 최솟값을 갱신해준다
    if grid[x][y] == 'O' and dist[x][y][K] > dist[x][y][oil] + 1: # 주유시에는 기름을 채우기만하고 이동은 하지 않음
        dist[x][y][K] = dist[x][y][oil] + 1
        que.append((x, y, K)) # 오른쪽에 넣으면 나중에 빠진다는  bfs 알고리즘 개념
# 0-1 BFS 알고리즘
# 상태 ( 정점 ) 변화 ( 간선 ) 의 탐색이 상당히 헷갈린다 요즘 많이 나오고 격자 혹은 배열 기억하는 느낌이 많이 출제된다
# 즉 기본적인 메모리 관점에서 어떤 상태 혹은 사건들을 기록해둔다라는 개념이 많이 등장한다
print(min(dist[n - 1][m - 1])) # 도착시점에서 남은 연료가 무엇이든 각 거리가 최소인 점을 찾으면된다 즉 기름을 가장 적게 넣은 것을 구하게 된다
