# 피자 메뉴가 있다
# P가지의 종류의 피자가 있다
# 각각의 피자에는 크기와 토핑 종류가 존재
# 피자의 번호가 커질수록 크기도 커지고 토핑도 누적되어서 증가
# 1번 피자 크기 : 100 토핑 : 1,3
# 2번 피자 크기 : 500 토핑 : 1,3,4 (1번피자의 토핑에서 추가 )
# 3번 피자 크기 : 2000 토핑 : 1,3,4,5 (2번피자의 토핑에서 추가 )
# N명의 사람이 존재 : 각 사람마다 최소한의 크기의 피자를 먹고싶다
# 1번째 사람 : 크기 300 먹고싶고 토핑은 3,5를 먹고 싶자 (1번피자는 안됨)(2번피자는 토핑이 5번이없다)(3번피자는 요건충족한다)
# 어떤 사람이 크기 100만큼 먹어도되고 토핑 1번정도만 먹는다면 1번 2번 3번 피자다 먹을수있는데 그 중 크기가 제일 작은 피자를 먹는다고 하자
# 각 사람이 먹는 최소한의 피자를 출력하면 된다 만약 먹을 수 없다면 -1을 출력한다
# 이분탐색으로 각 사람이 먹을 수 있는 피자를 찾는다 ( 정렬 필수 )
# 피자는 30만  /  사람수 5만명 /  토핑번호는 1~5만
# 각 사람이 먹고 싶은 토핑의 종류는 최대 20개이다 => 20개인 이유가 있다
# 모든 문제를 잘 읽고 N제한을 잘 봐야 한다 => 입력과 출력도 잘 봐야 한다 => 정보때문에 풀이가 달라질 수 있다
# 우선 한 사람만 보자
# 300만큼의 크기 와 3,5번 토핑을 먹고 싶다고 하자
# 가장 naive한 풀이는 각 사람마다 모든 피자를 확인하면서 볼 수 있다 => 사람수 5만 x 30만 => 150억
# 종종 풀이를 못 찾을 수 있는 경우 전략적으로 naive하게 풀자 ....... brute force......
# 관찰 : 어떤 사람이 먹을 수 있는 피자가 여러가지 .....
#        피자를 5번 6번 7번 피자를 먹을 수 있따고 생각하면 피자의 번호가 커질수록 부가적인 성질이 있는데
#        무조건 크기도 커지고 토핑도 다양해진다 그러면 어떤 사람이 5번 피자를 먹을 수 있다면 6번 7번 피자를 먹을 수 있을까? 있다 더이상 볼필요가 없다
#        5번피자가 크기도 충족되고 토핑도 이미 되어 있다고 간주되므로 당연히 그 뒤의 피자들은 가능할 것이다
# 여기까지 관찰을 했다면 이분탐색으로 범위를 확확 줄여갈 수 잇다
# 1번 ~ P번 피자까지 일일이 먹어보려는것이 아니라 어떤 특정한 번호를 직고 그것을 먹을 수 있다면
# 더이상 그 뒤의 피자는 볼 필요가 없으므로 그보다 작은 피자를 먹어보려고 시도한다
# 반대로 못먹는다면 더 큰 크기의 피자를 먹어보려고 시도할 것이다
# 이분탐색 이전에 할얘기.... 크기는 이분탐색으로 귀결됨
# 토핑은 이분탐색이 어렵다 .... 크기와는 다르게 본다
# 크기를 만족하는 X => 이분탐색으로 찾는다
# 토핑을 만족하는 Y => 토핑들이 누적이 되기때문에 어렵다 => P^2까지 되면서 30만의 제곱이됨 ....
# 즉 토핑은 다르게 접근해야 함 ( 저장할 수 없음 - 공간복잡도 메모리초과 )....
# 처음으로 토핑이 추가된 시점이 있을 것이다 그 이전의 토핑은 들고 있을 것이다...
# 먹고 싶은 토핑마다 추가된 시점을 안다면 먹고 싶은 토핑을 전부 들고 있는 피자는
# 그 시점들 중 최대가 되는 피자를 먹을 수 있다
# 즉 추가된 시점에서 최소한 토핑이 된 피자이므로 그 피자번호를 매기면된다
# 그 후에 나중에 각 사람이 먹으려는 피자의 토핑조건에 해당되는 피자번호의 최대값을 구하면
# 이전에 뿌렸던 토핑들은 신경쓰지 않아도 된다 예를들어 2번 5번 7번 토핑 각각이
# 5번 2번 10번 피자에서 추가됬다고 하면 7번토핑이 10번 피자에 마지막으로 추가된것이므로
# 10번 피자를 선택할것이다

import sys

si = sys.stdin.readline
n_topping, n_pizza, n_customer = map(int, si().split())
sizes = []  # 피자 번호 순 크기 배열
# 초기값은 가장 큰 피자의 번호를 설정한다 왜냐면 이 이상 더 큰 피자의 번호는 없기 때문에
added_topping = [n_pizza for _ in range(n_topping + 1)]  # added_topping[i] := i번 토핑이 추가된 피자의 번호
for i in range(n_pizza):
    size, *toppings = map(int, si().split())
    sizes.append(size)
    for topping in toppings:
        added_topping[topping] = i  # topping이 i번 피자에서 처음 추가됐더라~


def get_size_number(size):
    if size > sizes[-1]:
        return n_pizza
    l, r, mid, ans = 0, n_pizza - 1, 0, n_pizza - 1
    while l <= r:
        mid = (l + r) // 2
        if sizes[mid] >= size:
            ans = mid
            r = mid - 1
        else:
            l = mid + 1
    return ans


def get_topping_number(toppings):
    ans = -1
    for topping in toppings:
        ans = max(ans, added_topping[topping])
    return ans


for i in range(n_customer):
    required_size, *required_toppings = map(int, si().split())
    # 1. required_size 를 만족하는 피자 번호의 최솟값
    size_number = get_size_number(required_size)
    # 2. required_toppings 를 만족하는 피자 번호의 최솟값
    topping_number = get_topping_number(required_toppings)
    # 사이즈를 만족하는 피자의 번호 와 토핑을 만족하는 피자의 번호중 더 큰쪽이 크기와 토핑 둘다 만족하는 피자의 번호가 되므로
    # 둘의 피자의 번호를 비교한 후에 피자를 정한다
    ans = max(size_number, topping_number)
    # 가장 큰 크기의 피자의 번호라면 먹을 수 있는 피자가 없다는 뜻임
    if ans == n_pizza:
        ans = -1
    print(ans + 1)