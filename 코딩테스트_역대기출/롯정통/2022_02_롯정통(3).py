# n이 6개면 => 젓가락 7segment ( 디지털숫자로 젓가락넣어서 갯수로 숫자를 만듬)
# 0 9 111 14 41 77 이 여섯가지를 다 찾는것은 힘들어보임
# n이 50이면 엄청 많아질것같다
# 완전탐색은 오래걸리다
# 세야 될게 많은데 일일이 세기 힘들어  => dp로 접근
# 특정한 순서로 문제를 푼다 => 특정한 순서는
# 진짜 문제는 n 개의 젓가락으로 만들수잇는 숫자의 갯수
# 가짜 문제는 i개의 젓가락으로 만들 수 있는 숫자의 갯수
# 가짜문제로 진짜 문제를 풀 수 있는가? dy[i] : i개의 젓가락으로 만들수있는가
# 초깃값? dy[0] = 1 젓가락은 0개라면 아무숫자도 만들수없기때문에 1로 명시
# dy[1] 부터 dy[7] 까지 정의해본다
# dy[8]부터 점화식으로 푼다
# dy[i]
# i가 6이라면 7까지 만들수잇다
# 공통점을 묶을 경우 => 마지막으로 어떤 행동을 했느냐 기준으로 묶는것이 좋다
# 마지막이 0으로 끝나다 마지막이 1로끝나다 마지막이 2로 끝나다....마지막이 9로 끝나다
# i가 11인경우에는 실제정답 99
# 20  50  118 181  811 227 725 527 752.... 99개의 원소가 있을 것이다
# 0으로 끝나는애들 여러개 1로끝나는 애들 여러개 2로 끝나는 애들 여러개......
# 젓가락으로 숫자를 왼쪽부터 하나씩 만들어가다가 마지막에 끝나는 숫자들끼리 같은거 묵어서 갯수셋다
# 파티션이후 점확식으로 넘어감
# 0으로끝나는 집합 => 어떤 공통점? 첫번째는 젓가락을 11개 사용
# 마지막이 0으로 끝나는 공통점 => 0은 무조건 만들어야하니까 그 앞까지
# 0빼고 다섯개의 젓가락만 사용한다 c0는 다섯개의 젓가락으로 만들 수 있는 숫자의 갯수왁 ㅏㅌ다
# 그렇다면 점화식은 dy[i] = dy[i-6] => 이미 젓가락 5개를 사용해서 만들수있는숫자의 갯수를 구해놓았음
#  1을 만드는 젓가락의 수는 dy[i-2] => 이미 젓가락 9개를 사용해서 만들 수 있는 젓가락의수
# 2 , 3, .....9까지 각 앞서 젓가락을 이미 만들어놓은 갯수의 총합을 구하면 끝
# 근데 dy[0] = 예외로 빼야한다 왜냐면 01은 카운팅하지 않을것이다 => 마지막이 1로끝나는 경우도 가져오기 때문이다
# 그리고 단 0은 넣을 수 있으므로 마지막에 +1 카운팅을 해준다
import sys
si = sys.stdin.readline
N = int(si())
dy = [0 for _ in range(N + 1)]
dy[0] = 1
cnt = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]
for i in range(1, N + 1):
    for c in cnt:
        if i >= c:
            dy[i] += dy[i - c]
    if i == 6: # 예외가 있다 6개로 0을 만들게되면 i가 8일때 01을 만들게되므로 이것은 카운팅하지 않는다
        # 그래서 i==6일대 0으로 만드는 경우는 제외한다
        # 하지만 단 6일때는 0을 만들수잇으므로 나중에 더해주어야한다
        # N이 6이상일 경우 0을 만드는 방법을 제외하므로 6이상일때 0을 만드는 경우를 추가해준다
        dy[i] -= 1
if 6 <= N: dy[6] += 1
print(dy[N])
