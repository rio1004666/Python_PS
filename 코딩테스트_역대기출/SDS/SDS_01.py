# N행 M열에 숫자가 쓰여져있다
# 한 Round마다 두가지 step이 있다
# 1step 모든칸에 쓰여진 숫자에 1증가 시킨다
# 2step r번째 round라면 그 round에만 적용되는 k값이 주어진다
# 1라운드에서 if  k = 3  => 모든칸에 1증가 (1step)
# 2step에서 k=3이므로 3개의 가장 큰 숫자를 선택한다
# 선택된 숫자들에 대해서 각 숫자에서 1을 뺸 총합을 구한다
# 그게 이번 round에서 구한 점수이다
# 1라운드 끝나면 그 선택된 숫자들은 1로 바뀐다
# 모든 라운드 통들어 구해진 점수들의 총합을 구함
# 범위는 N과 M은 300이하
# K값은 최대 400 물론 NxM갯수보다 크다
# 라운드는 20000번까지 가능
# 1. 문제 제대로 이해하기
# 2. 내가 가장 아는 쉬운 풀이를 떠올려보자
# 3. 시뮬레이션 하자
# 매라운드마다 모든 칸에 1을 더해주는 작업해주고 (O(NM)
# k번에 걸쳐서 제일 최대값 구해서 점수에 누적 (O(NM) * K )
# 한라운드마다 O(NM) * K 가 된다
# O(NMKR)이 된다 ( 브루트 포스 풀이 ) 
# 그런데 이렇게 하면 시간초과 날것이 분명!!!
# 빠르게 만들 수 있는 것들을 만들자 
# 키워드는 최댓값을 찾고. 1로 바꾸는 작업????
# 2차원 배열로 굳이 들고 있을 필요가 없고
# 모든 숫자들을 가지고만 있으면 된다 
# 숫자들에게 최댓값이 머야 ? , 그리고 1로 바꾸는 작업
# 그런 자료구조....?? 우선순위큐. 숫자와 좌표를 들고 있는 우선순위 큐 힙
# 최대힙으로 관리하면 훨씬 줄일 수 있다
# 최댓값 찾는데 O(1) 삭제하는데 logNM으로 바뀐다
# 그런데 굳이 MAP 힙이어야 하나?? -> 아니다 ( 시간초과 여전하다 )
# 관찰. 격자안의 모든 원소가 1보다 크거나 같다
# 모든 자료중에서 제일 큰것을 뺀다 그다음에 1을 새로 넣는다
# 단순히 1인것보다 내가 이번에 넣을 원소는 무조건
# 이미 들어 잇는 자료보다 작거나 같은것을 보장인것을 넣는다
# 그러면 MAX HEAP이 아니더라도
# 이것을 빠르게 해주는것이 큐이다
# 큐에 대가 내림차순으로 넣었다면....
# 최댓값이 맨 앞에 있을 것이고 POP하면 O(1)이다
# 1삽입도 back에다가 넣어주기만 하면 O(1)이다
# 1이 무조건 최소값인것을 아니까 무조건 정렬됨을 보장함
# 이로써 삽입 , 삭제 모두 O(1)에다가 내림차순 정렬을 보장한다
# 즉 이러한 1이라는 특정한 수로 바꾸는데서 이문제의 키포인트이다.
# 그래서 굳이 최대힙을 써서 넣었다 뺏다해서 log를 하지 않아도 됨
# 그러면 시간복잡도는 현저하게 줄어든다
# O(KR+NMlog(NM))이 된다 (최초에 정렬한번하고 큐에 넣었을 때
# 남아 있는 관문은 어떻게 모든 원소에 1을 더할수 있을까?
# 이거를 해결 못하면 결국 O(NMKR)가 된다
# 큐에서 빼낼때마다 이때까지 진행해온 라운드수만큼 더해서
# 곱해준다 