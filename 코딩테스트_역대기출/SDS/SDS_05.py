# 격자가 주어짐
# N x M
# 특정위치에서 사람이 서 있음
# 특정위치는 벽으로 막혀서 사람이 지날 수 없음
# 최대 K번 이동 가능함
# 상하좌우로 이동 가능
# X(벽)칸은 못감
# 격자 밖으로 나가면 탈출
# K가 3이라면 최대 3번 이동 가능
# 같은 격자 칸 중복 방문 가능
# 브루트 포스로 풀면 4^500
# DP를 보통 생각하자 ( 자료구조나 다른 여타한 알고리즘이 떠오르지 않으면 )
# 경우의 수가 많은 경우 -> 효율성 DP
# 1. 테이블을 정의
# 느낌오는대로 정의만 잘하면 됨 -> 틀리면 진화시킴
# dp[k][r][c] = "정확히 k번 이동" 해서 r행 c열에 도착하는 경우의 수 의미
# dp[5][4][7] = 308이라면 시작위치에서 5번 이동해서 4행 7열에 도착하는 방법의 수가 308가지
# 2. 초깃값 정의
# dp[0][r][c] = 1
# 뿌려주는  dp 즉 bottom - up 작은 문제들로 큰문제들을 해결
# 가져오는  dp 큰 문제에서 작은문제들의 결과들을 가져와서 해결
# 점화식  dp[k+1][r][c+1] += dp[k][r][c] 오른쪽으로 이동했을 경우
#         dp[k+1][r+1][c] += dp[k][r][c] 왼쪽으로 이동했을 경우
# 탈출하는 위치로 벗어나게 되면 정답에 추가해주면 끝
# 시작위치를 찾아서 초깃값 설정을 우선 한다
# 거기만 1을 쓰고 나머지는 0을 써준다 (정답을 모름 ) 0가지 있다
# k=0일 때 시작 위치인 dp[0][6][7] 에서만 1이고 4가지 방향에 1번 이동 하는 것으로 치부한다
# k=1일 때는 나머지는 또 전부 0이고 dp[1][6][8] dp[1][6][6] dp[1][5][7] dp[1][7][7] 에서 또 4방향으로 dp[2][....가 값이 누적된다 경우의 수가

