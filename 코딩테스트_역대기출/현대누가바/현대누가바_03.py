# N자리 숫자를 만들고 싶고
# 각자리에 1~9까지 선택해서 숫자를 만들고 싶다
# 어떤 두 위치를 더해도 더한 결과가 9이면 안된다
# 9가 안되면 그 숫자는 가능한 값이다
# 경우의 수
# N = 100만자리까지 가능
# 관찰  => 합이 9다 라는 사실을 이용
# 1이면 다른 어디에 8을 못쓴다
# 완전탐색으로 하면 N^2으로 시간초과
# 9만 어디든지 쓸수잇다 더해도 9가 되지 않기에
# 수학적인풀이...?
# 완탐으로 안되면 DP
# 1 - 8 OR 2 - 7 OR 3 - 6  OR 4 - 5  가 9가 되는 관계가 성립한다
# 이 관계에서
# DP(N,K) = N자리 자연수중 정확히 K개의 선택지를 사용하게 됨 ( K 는 4개가 최대이다 ) -> 즉 나머지는 선택지외에 나머지 자리는 9를 채움으로써 어떤 두개를 선택해도 9가 안되게 한다
# 예를 들어  DP[5][0] => 5개자리 모두 위의 4가지 관계를 못쓰므로
# 9 9 9 9 9이다
# DP[5][1] = 5개 자리 중 하나는 4가지 관계를 사용할 수 잇따
# 계산해보면 A 9 9 9 9 혹은 9 9 9 9 A => 관계 A B C D 중 1개를 사용해도 된다
# DP[5][2] = 5개 자리 중 두개는 4가지 관계를 사용할 수 있다
# 초깃값은 DP[1][0] = 1 ( 9 인경우 ) 과 DP[1][1] = 1 ( A )
# DP 테이블을 사용함 DP[N][0] + DP[N][1] * 2 ( 1 - 8 혹은 8 - 1 관계 사용 ) * 4 (4개의 관계중 하나를 선택함 ) => 2 *  4P1
# + DP[N][2] * 2^2 * 4P2 + DP[N][3] * 2^3 * 4P3 + DP[N][4] * 2^4 * 4P4
# DP(N,K)
# 1번 N번째에 새로운 선택지 아닌 경우 즉 9인경우 DP[N-1][K]를 그대로 가져옴
# 선택지 중 하나 => DP[N-1][K] * K
# 새로운 선택지 선택 DP[N-1][K-1]


import sys
si = sys.stdin.readline
N = int(si())
MOD = 1000000007
dp = [[0 for _ in range(5)] for __ in range(N + 1)]
dp[1][0] = 1
dp[1][1] = 1
for n in range(2, N + 1):
    dp[n][0] = 1
    for k in range(1, 5):
        dp[n][k] = (dp[n - 1][k - 1] + dp[n - 1][k] * (k + 1)) % MOD
ans = 0
ans = dp[N][0] + \
    dp[N][1] * 2 * 4 + \
    dp[N][2] * 4 * 12 + \
    dp[N][3] * 8 * 24 + \
    dp[N][4] * 16 * 24
print(ans)