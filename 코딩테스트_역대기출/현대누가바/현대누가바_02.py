# 무한히 많은 정점
# 1번부터 무한대
# 간선이 어떻게 정의 되어 잇는가?
# i가 써져있는 정점과 i*2   써져 있는 정점과 연결
# i가 써져있는 정점과 i*2+1 써져 있는 정점과 연결
# 문제는  Q개의 질문이 들어오고
# S값과 T가 들어옴
# S 와 T의 최단거리
# LCA 로 해결
# 이 성질을 띄는 그래프가 HEAP  자료구조로 구현 가능
# FULL Binary Tree 형태로 띄게 되고
# 완전 이진 트리 => heap
# 모든 정점이 두개의 자식을 갖게 됨
# 인덱스를 루트에는 1번으로 두고
# 2 3 ( 왼쪽 자식, 오른쪽 자식 )
# 4 5 6 7 ( 왼쪽자식, 오른쪽 자식, 왼쪽 자식, 오른쪽 자식 )
# 결국 heap자료구조 사용
# 트리에서의 경우는 시작점을 찍고 다시 내려가는경우이므로
# 최단경로는 1번까지 쭉올라가는 선과 1번에서 내려오는 선
# 현재 레벨에서 루트레벨차이와 루트레벨에서 타겟레벨과의 차이를 계산한다
# 근데 루트까지 안올라가도 갈수잇는 경로가 있으므로 최단경로를 찍을 수 있다
# LCA는 최단경로의 반환점이 된다
# 트리에서의 반환점 특성은 한정점의 조상들과
# 다른정점의 조상들 중에서 처음으로 겹치는 가장 낮은 위치에서
# 그 정점이 반환점이다
# S의 조상들과 T의 조상들 중에서 공통 조상들이 있을 거고
# 그중에서 제일 아래에 있는 즉 레벨이 낮은 조상이
# 반환점이될거잇고 그 반환점을 기준으로 레벨 차이를 알면된다
# Lowest Common Acestor => 가장 낮은 공통적인 조상

# 관찰 => 0은 왼쪽이고 1은 오른쪽
# 13은 2진수로 표현하면 1101 => 첫번째 1무시 오른쪽 왼쪽 오른쪽이되고
# 1번루트에서 오른쪽 왼쪽 오른쪽으로 가면 13이된다
# 10은 1010 => 맨 첫번째 1은 무시하고 왼 오 왼 이고 가면 10이다!!!!!!!
# 이렇게 특정 노드로 가는 방법을 2진수로 표현하면 알 수 있다
# 루트에서 S까지 내려가는 경우 루트에서 T까지 내려가는 경우
# 같은 조상은 같은 비트값과 동일하므로 맨앞의 비트부터 비교하면서
# 다른 조상이 나오기전까지 비교하면서 가장 낮은 공통 조상을 찾는다
# 예를 들어서 1100과 1110은 앞의 11이 공통조상이고 그중에서 가장 낮은 공통조상은 두번째 1이 동일한 것이 공통조상이 된다
# 그리고 반환점에서 S로 가는길이와 T로 가는 길이를 더한 것이 최소 길이이다
# 나누기 2때리면서 공통조상을 구할 수도잇지만
# 시간적으로 복잡도는 O(1)이다


import sys

si = sys.stdin.readline
Q = int(si())
for _ in range(Q):
    S, T = map(int, si().split())
    S = bin(S)
    T = bin(T)
    i = 0
    while True:
        if i == len(S) or i == len(T):
            break
        if S[i] != T[i]:
            break
        i += 1

    print(len(S) - i + len(T) - i)